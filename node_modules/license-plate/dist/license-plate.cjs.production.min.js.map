{"version":3,"file":"license-plate.cjs.production.min.js","sources":["../src/data/sidecodes.ts","../src/data/letter-combinations.ts","../src/license-plate.ts"],"sourcesContent":["/**\n * All dutch available sidecodes.\n *\n * @type {RegExp[]}\n */\nconst sidecodes: RegExp[] = [\n\t/^([a-zA-Z]{2})([0-9]{2})([0-9]{2})$/,    // [1]  => XX-99-99\n\t/^([0-9]{2})([0-9]{2})([a-zA-Z]{2})$/,    // [2]  => 99-99-XX\n\t/^([0-9]{2})([a-zA-Z]{2})([0-9]{2})$/,    // [3]  => 99-XX-99\n\t/^([a-zA-Z]{2})([0-9]{2})([a-zA-Z]{2})$/, // [4]  => XX-99-XX\n\t/^([a-zA-Z]{2})([a-zA-Z]{2})([0-9]{2})$/, // [5]  => XX-XX-99\n\t/^([0-9]{2})([a-zA-Z]{2})([a-zA-Z]{2})$/, // [6]  => 99-XX-XX\n\t/^([0-9]{2})([a-zA-Z]{3})([0-9])$/,       // [7]  => 99-XXX-9\n\t/^([0-9])([a-zA-Z]{3})([0-9]{2})$/,       // [8]  => 9-XXX-99\n\t/^([a-zA-Z]{2})([0-9]{3})([a-zA-Z])$/,    // [9]  => XX-999-X\n\t/^([a-zA-Z])([0-9]{3})([a-zA-Z]{2})$/,    // [10] => X-999-XX\n\t/^([a-zA-Z]{3})([0-9]{2})([a-zA-Z])$/,    // [11] => XXX-99-X\n\t/^([a-zA-Z])([0-9]{2})([a-zA-Z]{3})$/,    // [12] => X-99-XXX\n\t/^([0-9])([a-zA-Z]{2})([0-9]{3})$/,       // [13] => 9-XX-999\n\t/^([0-9]{3})([a-zA-Z]{2})([0-9])$/,       // [14] => 999-XX-9\n];\n\nexport default sidecodes;\n","/**\n * All forbidden words in license plates.\n *\n * @type {string[]}\n */\nconst forbiddenWords: string[] = [\n  'GVD',\n  'KKK',\n  'KVT',\n  'LPF',\n  'NSB',\n  'PKK',\n  'PSV',\n  'TBS',\n  'SS',\n  'SD',\n];\n\nexport default forbiddenWords;","import sidecodes from './data/sidecodes';\nimport forbiddenWords from './data/letter-combinations';\n\nexport default class LicensePlate {\n  /**\n   * License plate.\n   *\n   * @private\n   * @readonly\n   * @type {string}\n   */\n  private readonly licensePlate: string;\n\n  /**\n   * Constructs the licence plate with the input value as uppercase.\n   */\n  constructor(licensePlate: string) {\n    this.licensePlate = licensePlate.replace(/-/g, '').toUpperCase();\n  }\n\n  /**\n   * Checks if the given license plate is valid.\n   *\n   * @public\n   * @return {boolean} True if sidecode matches, false if none matches.\n   */\n  public valid(): boolean {\n    return this.sidecode() !== 0 && !this.forbidden();\n  }\n\n  /**\n   * Finds the matching sidecode by the given license plate. and returns\n   * the index of the sidecode in a human-readable format (+1).\n   *\n   * @public\n   * @return {number} The index of the sidecode, 0 if not found.\n   */\n  public sidecode(): number {\n    return sidecodes.findIndex((sidecode: RegExp) => this.licensePlate.match(sidecode)) + 1;\n  }\n\n  /**\n   * Finds the matching sidecode and returns the Regex pattern associated.\n   *\n   * @private\n   * @return {RegExp} The Regex pattern.\n   */\n  private getSidecodePattern(): RegExp {\n    return sidecodes[this.sidecode() - 1];\n  }\n\n  /**\n   * Converts a license plate to the Regex equivalent based on the sidecode found.\n   *\n   * @private\n   * @param sidecode {RegExp} The Regex pattern to use when converting input plate.\n   */\n  private convertPlate(sidecode: RegExp): string {\n    let matches = this.licensePlate.match(sidecode) ?? [];\n    matches.shift();\n\n    return matches.join('-');\n  }\n\n  /**\n   * Formats the input license plate to real license plate based on the matched sidecode.\n   *\n   * @public\n   * @returns {string} The formatted license plate.\n   */\n  public pretty(): string {\n    const pattern = this.getSidecodePattern()\n\n    return this.convertPlate(pattern);\n  }\n\n  /**\n   * Checks whether the given license plate included some forbidden letter combinations.\n   *\n   * Starting from sidecode 7, political abbreviations from political parties were excluded,\n   * except VVD, they were excluded starting from sidecode 8.\n   *\n   * Sources:\n   * https://nl.wikipedia.org/wiki/Nederlands_kenteken\n   * https://www.rdw.nl/particulier/voertuigen/auto/de-kentekenplaat/cijfers-en-letters-op-de-kentekenplaat\n   *\n   * @return {boolean}\n   * @private\n   */\n  private forbidden(): boolean {\n    let forbidden = forbiddenWords;\n\n    if (this.sidecode() >= 7) {\n      forbidden = [...forbidden, 'PVV', 'SGP'];\n    }\n\n    if (this.sidecode() >= 8) {\n      forbidden = [...forbidden, 'VVD'];\n    }\n\n    const formattedPlate = this.pretty();\n\n    return forbidden.some((word: string) => formattedPlate.includes(word));\n  }\n}\n"],"names":["sidecodes","forbiddenWords","licensePlate","replace","toUpperCase","valid","this","sidecode","forbidden","findIndex","_this","match","getSidecodePattern","convertPlate","matches","shift","join","pretty","pattern","formattedPlate","some","word","includes"],"mappings":"oEAKA,IAAMA,EAAsB,CAC3B,sCACA,sCACA,sCACA,yCACA,yCACA,yCACA,mCACA,mCACA,sCACA,sCACA,sCACA,sCACA,mCACA,oCCdKC,EAA2B,CAC/B,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,4CCCYC,QACLA,aAAeA,EAAaC,QAAQ,KAAM,IAAIC,yCAS9CC,MAAA,kBACsB,IAApBC,KAAKC,aAAqBD,KAAKE,eAUjCD,SAAA,6BACEP,EAAUS,WAAU,SAACF,UAAqBG,EAAKR,aAAaS,MAAMJ,MAAa,KAShFK,mBAAA,kBACCZ,EAAUM,KAAKC,WAAa,MAS7BM,aAAA,SAAaN,SACfO,WAAUR,KAAKJ,aAAaS,MAAMJ,MAAa,UACnDO,EAAQC,QAEDD,EAAQE,KAAK,QASfC,OAAA,eACCC,EAAUZ,KAAKM,4BAEdN,KAAKO,aAAaK,MAgBnBV,UAAA,eACFA,EAAYP,EAEZK,KAAKC,YAAc,IACrBC,YAAgBA,GAAW,MAAO,SAGhCF,KAAKC,YAAc,IACrBC,YAAgBA,GAAW,aAGvBW,EAAiBb,KAAKW,gBAErBT,EAAUY,MAAK,SAACC,UAAiBF,EAAeG,SAASD"}